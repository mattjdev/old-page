---
layout: post
title: How It All Started
---

This is an intro post to this blog to get a better understanding of where I come from and who I am, as well as what to expect from this blog.

---

## My Background
<br />
#### In the Beginning

I started programming in Java back in high school. Nope, I never programmed in Fortran or Cobol or any other old*er* language, I was lucky enough to start with Java 6 I believe it was.  

I started off completely naive of what I was doing and how it was working. The class worked its way up from Hello World to working on a command line calculator. Typical programming for beginners stuff. The next year was a self-led class (since nobody really took a second year of programming in my high school) where we got assignments from the teacher, but we were in charge of the pace. Most of the year was advanced topics like graphical user interfaces, and this fish case study that involved drawing a single fish and then duplicating it and moving it around and such. I even learned to program my TI calculator (on my own, not from class). I created some maze game with 10 levels and a hidden easter egg (I ***LOVE*** easter eggs!). 

I remember how curious I was about what made it all work. It wasn't enough for me to be able to just type human-readable text into the editor and voila it works; I wanted to know what was really happening. There were no classes in my high school that taught that kind of thing, and google was still too young to be able to google *any*thing and get an answer just like that (I think we were instructed by the school to use [dogpile](http://www.dogpile.com) at the time). So, naturally, I went to college for **knowledge**.


#### From the Bottom Up

If you ask me what I learned in college, I will probably tell you I learned how to teach myself anything I needed to know to make myself more valuable. Some of that came from my natural curiosity, and some came from the lack of confidence in some professors I had.

What I **do** remember learning from classes was how computers worked (finally!). I learned that computer programs made up of text is converted to assembly language which is just a representation of binary commands. That assembly/binary is then fed into a processor which is really just a super fast calculator that can calculate memory addresses and fetch data and 'process' it. Literally, most processor commands are broken down into arithmetic (add/subtract), memory communication (load/store memory), logic (and/or), and jumping/branching to different lines of code. (Of course, processors have been optimized to combine a lot of these tasks into a single command, but that's beside the point of this story). Once it was broken down for me I realized that a computer is actually *really* simple, but is able to do extraordinary things.
(**Side Note**: I do **not** think *creating* a computer system is simple in the slightest, and I respect the people who do it, because I couldn't). 

What I really took out of a lot of this information was how to break problems into the simplest forms to be able to solve individually, because that is exactly what processors do. That IF statement is made up of several commands that basically check the answer and go to a different spot in the code depending on whatever result it gets from the processor; the same way that an application is made up of several modules that can be divided out and worked on separately; and each module will be made up of classes or functions, full of IF statements, loops and variables. This is the fascinating world of programming: things that seem so simple, and once learned seem so easy, can come together to make extraordinary applications and devices that have proliferated throughout this world and are now used every second of every day.


#### Back to the Top

After being able to understand all of the workings of the lower-level, I could then truly appreciate how software works at the higher-level. It allows me to think about everything I do in software development just a little bit differently. 

I went on to learn software engineering processes and techniques to create quality code from the beginning, and the value of creating code that does the right thing instead of code that does cool things (though hopefully they will be one in the same most of the time). I learned about the importance of reusability (don't keep reinventing the wheel), design patterns (if someone has already come up with a solution, use it), and architecture (don't create a house of cards). All of the necessary concepts every software engineer should know and internalize.

---

## Going Forward

What I hope this blog site could be is somewhat of a personal brain dump for me to collect my thoughts and put it into a concrete medium that I could look back to later, as well as be a good collective reference for others to use. I just want to make sure that whatever content that I put out can be helpful to someone and succinct enough to answer their question quickly and effectively.

This is going to be a technical blog and my expertise is in web technologies, software algorithms, development processes, and technical critiques; so expect the blog posts to fall into one of those categories.

If you ever have any ideas on a post you would like to see, share it in the comments below and I will be sure to look it up and schedule a time to write about it.
